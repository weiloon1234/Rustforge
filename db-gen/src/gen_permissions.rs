use crate::permissions::PermissionEntry;
use std::collections::BTreeSet;
use std::error::Error;
use std::fmt::Write as _;
use std::fs;
use std::path::Path;

pub fn generate_permissions(
    entries: &[PermissionEntry],
    out_file: &Path,
) -> Result<(), Box<dyn Error>> {
    if let Some(parent) = out_file.parent() {
        fs::create_dir_all(parent)?;
    }

    let mut out = String::from("// Auto-generated by db-gen. Do not edit.\n\n");
    out.push_str("use schemars::JsonSchema;\n");
    out.push_str("use serde::{Deserialize, Serialize};\n\n");

    out.push_str("#[derive(Debug, Clone, Copy, Serialize, Deserialize, JsonSchema)]\n");
    out.push_str("pub struct PermissionMeta {\n");
    out.push_str("    pub key: &'static str,\n");
    out.push_str("    pub guard: &'static str,\n");
    out.push_str("    pub label: &'static str,\n");
    out.push_str("    pub group: &'static str,\n");
    out.push_str("    pub description: &'static str,\n");
    out.push_str("}\n\n");

    let mut variants = Vec::with_capacity(entries.len());
    let mut used = BTreeSet::new();
    for entry in entries {
        let base = key_to_variant(&entry.key);
        let mut name = base.clone();
        let mut suffix = 2usize;
        while used.contains(&name) {
            name = format!("{base}{suffix}");
            suffix += 1;
        }
        used.insert(name.clone());
        variants.push((name, entry));
    }

    out.push_str(
        "#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, JsonSchema)]\n",
    );
    out.push_str("pub enum Permission {\n");
    for (name, entry) in &variants {
        writeln!(out, "    #[serde(rename = \"{}\")]", escape(&entry.key))?;
        writeln!(out, "    {name},")?;
    }
    out.push_str("}\n\n");

    out.push_str("pub const PERMISSION_META: &[PermissionMeta] = &[\n");
    for (_, entry) in &variants {
        writeln!(
            out,
            "    PermissionMeta {{ key: \"{}\", guard: \"{}\", label: \"{}\", group: \"{}\", description: \"{}\" }},",
            escape(&entry.key),
            escape(&entry.guard),
            escape(&entry.label),
            escape(&entry.group),
            escape(&entry.description)
        )?;
    }
    out.push_str("];\n\n");

    out.push_str("impl Permission {\n");
    out.push_str("    pub const fn as_str(self) -> &'static str {\n");
    if variants.is_empty() {
        out.push_str("        match self {}\n");
    } else {
        out.push_str("        match self {\n");
        for (name, entry) in &variants {
            writeln!(
                out,
                "            Self::{name} => \"{}\",",
                escape(&entry.key)
            )?;
        }
        out.push_str("        }\n");
    }
    out.push_str("    }\n\n");

    out.push_str("    pub fn from_str(value: &str) -> Option<Self> {\n");
    out.push_str("        match value {\n");
    for (name, entry) in &variants {
        writeln!(
            out,
            "            \"{}\" => Some(Self::{name}),",
            escape(&entry.key)
        )?;
    }
    out.push_str("            _ => None,\n");
    out.push_str("        }\n");
    out.push_str("    }\n\n");

    out.push_str("    pub const fn all() -> &'static [Self] {\n");
    out.push_str("        &[\n");
    for (name, _) in &variants {
        writeln!(out, "            Self::{name},")?;
    }
    out.push_str("        ]\n");
    out.push_str("    }\n\n");

    out.push_str("    pub const fn guard(self) -> &'static str {\n");
    if variants.is_empty() {
        out.push_str("        match self {}\n");
    } else {
        out.push_str("        match self {\n");
        for (name, entry) in &variants {
            writeln!(
                out,
                "            Self::{name} => \"{}\",",
                escape(&entry.guard)
            )?;
        }
        out.push_str("        }\n");
    }
    out.push_str("    }\n\n");

    out.push_str("    pub const fn meta(self) -> &'static PermissionMeta {\n");
    if variants.is_empty() {
        out.push_str("        match self {}\n");
    } else {
        out.push_str("        match self {\n");
        for (idx, (name, _)) in variants.iter().enumerate() {
            writeln!(out, "            Self::{name} => &PERMISSION_META[{idx}],")?;
        }
        out.push_str("        }\n");
    }
    out.push_str("    }\n\n");

    out.push_str("    pub fn by_guard(guard: &str) -> Vec<Self> {\n");
    out.push_str("        Self::all()\n");
    out.push_str("            .iter()\n");
    out.push_str("            .copied()\n");
    out.push_str(
        "            .filter(|permission| permission.guard().eq_ignore_ascii_case(guard))\n",
    );
    out.push_str("            .collect()\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    out.push_str("impl std::fmt::Display for Permission {\n");
    out.push_str("    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n");
    out.push_str("        f.write_str(self.as_str())\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    out.push_str("\nimpl AsRef<str> for Permission {\n");
    out.push_str("    fn as_ref(&self) -> &str {\n");
    out.push_str("        self.as_str()\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    fs::write(out_file, out)?;
    Ok(())
}

fn key_to_variant(key: &str) -> String {
    if key.trim() == "*" {
        return "All".to_string();
    }

    let mut parts = Vec::new();
    let mut cur = String::new();
    for ch in key.chars() {
        if ch.is_ascii_alphanumeric() {
            cur.push(ch);
        } else if !cur.is_empty() {
            parts.push(cur.clone());
            cur.clear();
        }
    }
    if !cur.is_empty() {
        parts.push(cur);
    }

    let mut out = String::new();
    for part in parts {
        let mut chars = part.chars();
        if let Some(first) = chars.next() {
            out.push(first.to_ascii_uppercase());
            out.push_str(chars.as_str());
        }
    }

    if out.is_empty() {
        return "Permission".to_string();
    }

    if out
        .chars()
        .next()
        .map(|c| c.is_ascii_digit())
        .unwrap_or(false)
    {
        format!("P{out}")
    } else {
        out
    }
}

fn escape(value: &str) -> String {
    value.replace('\\', "\\\\").replace('\"', "\\\"")
}
