use crate::config::{ConfigsFile, Locales};
use crate::schema::{parse_attachments, to_owner_type, to_snake, to_title_case, Schema};
use std::collections::BTreeSet;
use std::error::Error;
use std::fs;

pub fn generate_localized(
    locales: &Locales,
    cfgs: &ConfigsFile,
    schema: &Schema,
    out_dir: &std::path::Path,
) -> Result<(), Box<dyn Error>> {
    let mut out = String::new();
    let has_loader_functions = schema.models.values().any(|cfg| {
        cfg.multilang.is_some() || cfg.meta.is_some() || !parse_attachments(cfg).is_empty()
    });
    let needs_resize_rule = cfgs
        .attachment_types
        .values()
        .any(|attachment_type| attachment_type.resize.is_some());

    out.push_str("#![allow(dead_code)]\n");
    out.push_str("// AUTO-GENERATED FILE â€” DO NOT EDIT\n");
    out.push_str("// Generated by build.rs from schema.toml + configs.toml\n\n");

    if has_loader_functions {
        out.push_str("use anyhow::Result;\n");
        out.push_str("use core_db::common::sql::DbConn;\n\n");
    }
    if needs_resize_rule {
        out.push_str("use core_db::platform::attachments::types::{AttachmentRules, ResizeRule};\n");
    } else {
        out.push_str("use core_db::platform::attachments::types::AttachmentRules;\n");
    }

    out.push_str(&format!(
        "pub const DEFAULT_LOCALE: &str = \"{}\";\n\n",
        locales.default
    ));

    let timezone = locales.timezone.as_deref().unwrap_or("+00:00");
    out.push_str(&format!(
        "pub const DEFAULT_TIMEZONE: &str = \"{}\";\n\n",
        timezone
    ));

    out.push_str("pub const SUPPORTED_LOCALES: &[&str] = &[\n");
    for lang in &locales.supported {
        out.push_str(&format!("    \"{}\",\n", lang));
    }
    out.push_str("];\n\n");

    // Generate Locale Enum
    out.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize, schemars::JsonSchema)]\n");
    out.push_str("pub enum Locale {\n");
    for lang in &locales.supported {
        let variant = to_title_case(lang);
        out.push_str(&format!("    #[serde(rename = \"{}\")]\n", lang));
        out.push_str(&format!("    {},\n", variant));
    }
    out.push_str("}\n\n");

    out.push_str("impl Locale {\n");
    out.push_str("    pub fn as_str(&self) -> &'static str {\n");
    out.push_str("        match self {\n");
    for lang in &locales.supported {
        let variant = to_title_case(lang);
        out.push_str(&format!(
            "            Locale::{} => \"{}\",\n",
            variant, lang
        ));
    }
    out.push_str("        }\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    out.push_str("impl From<Locale> for String {\n");
    out.push_str("    fn from(l: Locale) -> Self {\n");
    out.push_str("        l.as_str().to_string()\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    out.push_str("impl std::fmt::Display for Locale {\n");
    out.push_str("    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n");
    out.push_str("        write!(f, \"{}\", self.as_str())\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    let mut owner_consts: BTreeSet<String> = BTreeSet::new();

    out.push_str(
        "#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, schemars::JsonSchema)]\n",
    );
    out.push_str("pub struct MultiLang {\n");
    for lang in &locales.supported {
        out.push_str(&format!("    pub {}: String,\n", lang));
    }
    out.push_str("}\n\n");

    out.push_str("impl MultiLang {\n");
    out.push_str("    pub fn get(&self, locale: &str) -> &str {\n");
    out.push_str("        match locale {\n");
    for lang in &locales.supported {
        out.push_str(&format!("            \"{}\" => &self.{},\n", lang, lang));
    }
    out.push_str(&format!("            _ => &self.{},\n", locales.default));
    out.push_str("        }\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");
    out.push_str("pub trait LocalizedMapHelper {\n");
    out.push_str("    fn get_multilang(&self, field: &str, owner_id: i64) -> Option<MultiLang>;\n");
    out.push_str("}\n\n");

    out.push_str(
        "impl LocalizedMapHelper for core_db::platform::localized::types::LocalizedMap {\n",
    );
    out.push_str(
        "    fn get_multilang(&self, field: &str, owner_id: i64) -> Option<MultiLang> {\n",
    );
    out.push_str("        let by_owner = self.inner.get(field)?;\n");
    out.push_str("        let by_locale = by_owner.get(&owner_id)?;\n");
    out.push_str("        if by_locale.is_empty() { return None; }\n");
    out.push_str("        let mut out = MultiLang {\n");
    for lang in &locales.supported {
        out.push_str(&format!("            {}: String::new(),\n", lang));
    }
    out.push_str("        };\n");
    out.push_str("        for &loc in SUPPORTED_LOCALES {\n");
    out.push_str("            if let Some(v) = by_locale.get(loc) {\n");
    out.push_str("                match loc {\n");
    for lang in &locales.supported {
        out.push_str(&format!(
            "                    \"{}\" => out.{} = v.clone(),\n",
            lang, lang
        ));
    }
    out.push_str("                    _ => {}\n");
    out.push_str("                }\n");
    out.push_str("            }\n");
    out.push_str("        }\n");
    out.push_str("        if let Some(default_val) = by_locale.get(DEFAULT_LOCALE) {\n");
    for lang in &locales.supported {
        out.push_str(&format!(
            "            if out.{}.is_empty() {{ out.{} = default_val.clone(); }}\n",
            lang, lang
        ));
    }
    out.push_str("        }\n");
    out.push_str("        Some(out)\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");
    for (name, cfg) in &schema.models {
        let Some(multilang_fields) = &cfg.multilang else {
            continue;
        };
        let model_snake = to_snake(name);
        let model_title = to_title_case(&model_snake);
        let model_const = model_snake.to_uppercase();
        let owner_type = to_owner_type(name);

        if owner_consts.insert(model_const.clone()) {
            out.push_str(&format!(
                "pub const {model_const}_OWNER_TYPE: &str = \"{owner_type}\";\n"
            ));
        }
        out.push_str(&format!("pub const {model_const}_FIELDS: &[&str] = &[\n"));
        for field in multilang_fields {
            out.push_str(&format!("    \"{}\",\n", field));
        }
        out.push_str("];\n\n");

        out.push_str(&format!(
            "pub async fn load_{model_snake}_localized<'a>(db: DbConn<'a>, ids: &[i64]) -> Result<core_db::platform::localized::types::LocalizedMap> {{\n"
        ));
        out.push_str(&format!(
            "    core_db::platform::localized::repo::LocalizedRepo::new(db)\n        .load_for_owners({model_const}_OWNER_TYPE, ids, {model_const}_FIELDS)\n        .await\n"
        ));
        out.push_str("}\n\n");

        let trait_name = format!("{}Localized", model_title);
        out.push_str(&format!("pub trait {} {{\n", trait_name));
        for field in multilang_fields {
            let field_snake = to_snake(field);
            out.push_str(&format!(
                "    fn {model_snake}_{field_snake}_translations(&self, id: i64) -> Option<crate::generated::MultiLang>;\n"
            ));
            out.push_str(&format!(
                "    fn {model_snake}_{field_snake}(&self, id: i64) -> Option<String>;\n"
            ));
        }
        out.push_str("}\n\n");

        out.push_str(&format!(
            "impl {} for core_db::platform::localized::types::LocalizedMap {{\n",
            trait_name
        ));
        for field in multilang_fields {
            let field_snake = to_snake(field);
            out.push_str(&format!(
                "    fn {model_snake}_{field_snake}_translations(&self, id: i64) -> Option<crate::generated::MultiLang> {{\n"
            ));
            out.push_str(&format!("        self.get_multilang(\"{}\", id)\n", field));
            out.push_str("    }\n");

            out.push_str(&format!(
                "    fn {model_snake}_{field_snake}(&self, id: i64) -> Option<String> {{\n"
            ));
            out.push_str("        let locale = core_i18n::current_locale();\n");
            out.push_str(&format!(
                "        self.get_value(\"{}\", id, locale)\n",
                field
            ));
            out.push_str("    }\n");
        }
        out.push_str("}\n\n");
    }

    // Attachment type rules from configs.toml
    out.push_str("pub fn get_attachment_rules(name: &str) -> Option<AttachmentRules> {\n");
    out.push_str("    match name {\n");
    for (name, t) in &cfgs.attachment_types {
        out.push_str(&format!(
            "        \"{n}\" => Some(AttachmentRules {{\n",
            n = name
        ));
        out.push_str("            allowed: vec![\n");
        for a in &t.allowed {
            out.push_str(&format!("                \"{}\".to_string(),\n", a));
        }
        out.push_str("            ],\n");
        if let Some(r) = &t.resize {
            out.push_str("            resize: Some(ResizeRule {\n");
            if let Some(w) = r.width {
                out.push_str(&format!("                width: Some({}),\n", w));
            } else {
                out.push_str("                width: None,\n");
            }
            if let Some(h) = r.height {
                out.push_str(&format!("                height: Some({}),\n", h));
            } else {
                out.push_str("                height: None,\n");
            }
            if let Some(q) = r.quality {
                out.push_str(&format!("                quality: Some({}),\n", q));
            } else {
                out.push_str("                quality: None,\n");
            }
            out.push_str("            }),\n");
        } else {
            out.push_str("            resize: None,\n");
        }
        out.push_str("        }),\n");
    }
    out.push_str("        _ => None,\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    // Meta helpers/constants
    for (name, cfg) in &schema.models {
        let Some(meta_fields) = &cfg.meta else {
            continue;
        };
        let model_snake = to_snake(name);
        let model_const = model_snake.to_uppercase();
        let owner_type = to_owner_type(name);

        if cfg.multilang.is_none() && owner_consts.insert(model_const.clone()) {
            out.push_str(&format!(
                "pub const {model_const}_OWNER_TYPE: &str = \"{owner_type}\";\n"
            ));
        }
        out.push_str(&format!(
            "pub const {model_const}_META_FIELDS: &[&str] = &[\n"
        ));
        for field in meta_fields {
            let mut parts = field.splitn(2, ':');
            let fname = parts.next().unwrap_or("");
            out.push_str(&format!("    \"{}\",\n", fname));
        }
        out.push_str("];\n\n");

        out.push_str(&format!(
            "pub async fn load_{model_snake}_meta<'a>(db: DbConn<'a>, ids: &[i64]) -> Result<core_db::platform::meta::types::MetaMap> {{\n"
        ));
        out.push_str(&format!(
            "    core_db::platform::meta::repo::MetaRepo::new(db)\n        .load_for_owners({model_const}_OWNER_TYPE, ids, {model_const}_META_FIELDS)\n        .await\n"
        ));
        out.push_str("}\n\n");
    }

    // Attachment helpers/constants
    for (name, cfg) in &schema.models {
        let attachment_fields = parse_attachments(cfg);
        if attachment_fields.is_empty() {
            continue;
        }
        let model_snake = to_snake(name);
        let model_const = model_snake.to_uppercase();
        let owner_type = to_owner_type(name);
        if cfg.multilang.is_none() && cfg.meta.is_none() && owner_consts.insert(model_const.clone())
        {
            out.push_str(&format!(
                "pub const {model_const}_OWNER_TYPE: &str = \"{owner_type}\";\n"
            ));
        }
        out.push_str(&format!(
            "pub const {model_const}_ATTACHMENT_FIELDS: &[&str] = &[\n"
        ));
        for field in &attachment_fields {
            out.push_str(&format!("    \"{}\",\n", field.name));
        }
        out.push_str("];\n\n");
        out.push_str(&format!(
            "pub async fn load_{model_snake}_attachments<'a>(db: DbConn<'a>, ids: &[i64]) -> Result<core_db::platform::attachments::types::AttachmentMap> {{\n"
        ));
        out.push_str(&format!(
            "    core_db::platform::attachments::repo::AttachmentRepo::new(db)\n        .load_for_owners({model_const}_OWNER_TYPE, ids, {model_const}_ATTACHMENT_FIELDS)\n        .await\n"
        ));
        out.push_str("}\n\n");
    }

    fs::write(out_dir.join("localized.rs"), out)?;
    Ok(())
}
