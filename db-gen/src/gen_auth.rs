use crate::config::ConfigsFile;
use crate::schema::{to_snake, to_title_case};
use std::error::Error;
use std::fmt::Write as FmtWrite; // for String
use std::fs;
use std::io::Write as IoWrite; // for File
use std::path::Path;

pub fn generate_auth(configs: &ConfigsFile, out_dir: &Path) -> Result<(), Box<dyn Error>> {
    fs::create_dir_all(out_dir)?;

    let mut mod_out = String::from("// Auto-generated by db-gen. Do not edit.\n\n");
    let mut guard_structs: Vec<String> = Vec::new();

    for (name, config) in &configs.auth.guards {
        let snake_name = to_snake(name);
        let file_stem = format!("{}_guard", snake_name);
        let struct_name = format!("{}Guard", to_title_case(name));
        let provider = &config.provider;
        let provider_snake = to_snake(provider);
        let provider_title = to_title_case(provider);

        let dest_path = out_dir.join(format!("{}.rs", file_stem));
        let mut f = fs::File::create(&dest_path)?;

        writeln!(f, "// Auto-generated by db-gen. Do not edit.")?;
        writeln!(f, "use async_trait::async_trait;")?;
        writeln!(f, "use core_db::common::sql::DbConn;")?;
        writeln!(
            f,
            "use core_db::platform::personal_access_tokens::model::PersonalAccessTokenRow;"
        )?;
        writeln!(
            f,
            "use core_db::platform::personal_access_tokens::repo::PatRepo;"
        )?;
        writeln!(f, "use uuid::Uuid;")?;
        writeln!(f, "use core_web::auth::Guard;")?;
        writeln!(
            f,
            "use crate::generated::models::{}::{{{}View, {}Query}};",
            provider_snake, provider_title, provider_title
        )?;
        writeln!(f)?;

        // Struct Definition
        writeln!(f, "/// {} Guard", struct_name)?;
        writeln!(f, "#[derive(Clone, Copy)]")?;
        writeln!(f, "pub struct {};", struct_name)?;
        writeln!(f)?;

        // Guard Trait Impl
        writeln!(f, "#[async_trait]")?;
        writeln!(f, "impl Guard for {} {{", struct_name)?;

        writeln!(f, "    type User = {}View;", provider_title)?;

        writeln!(f, "    fn name() -> &'static str {{")?;
        writeln!(f, "        \"{}\"", name)?;
        writeln!(f, "    }}")?;

        writeln!(f, "    fn tokenable_type() -> Option<&'static str> {{")?;
        writeln!(f, "        Some(\"{}\")", provider)?;
        writeln!(f, "    }}")?;

        writeln!(f, "    async fn fetch_user<'a>(db: DbConn<'a>, id: Uuid) -> anyhow::Result<Option<Self::User>> {{")?;
        writeln!(
            f,
            "        {}Query::new(db, None).find(id).await",
            provider_title
        )?;
        writeln!(f, "    }}")?;
        writeln!(f, "}}")?;
        writeln!(f)?;
        writeln!(
            f,
            "pub async fn list_tokens<'a>(db: DbConn<'a>, subject_id: Uuid) -> anyhow::Result<Vec<PersonalAccessTokenRow>> {{"
        )?;
        writeln!(
            f,
            "    let tokenable_type = <{} as Guard>::tokenable_type().unwrap_or(<{} as Guard>::name());",
            struct_name, struct_name
        )?;
        writeln!(
            f,
            "    PatRepo::new(db).list_by_subject(tokenable_type, subject_id).await"
        )?;
        writeln!(f, "}}")?;
        writeln!(f)?;
        writeln!(
            f,
            "pub async fn revoke_tokens<'a>(db: DbConn<'a>, subject_id: Uuid) -> anyhow::Result<u64> {{"
        )?;
        writeln!(
            f,
            "    let tokenable_type = <{} as Guard>::tokenable_type().unwrap_or(<{} as Guard>::name());",
            struct_name, struct_name
        )?;
        writeln!(
            f,
            "    PatRepo::new(db).revoke_by_subject(tokenable_type, subject_id).await"
        )?;
        writeln!(f, "}}")?;

        // Update mod.rs - Using fmt::Write for String
        writeln!(mod_out, "pub mod {};", file_stem)?;
        writeln!(mod_out, "pub use {}::*;", file_stem)?;
        guard_structs.push(struct_name);
    }

    writeln!(mod_out)?;
    writeln!(mod_out, "use std::collections::BTreeMap;")?;
    writeln!(mod_out, "use core_web::auth::AuthIdentity;")?;
    writeln!(mod_out, "use core_datatable::DataTableActor;")?;
    writeln!(mod_out)?;
    writeln!(
        mod_out,
        "pub async fn authenticate_any_guard(db: &sqlx::PgPool, token: &str) -> Option<AuthIdentity> {{"
    )?;
    if guard_structs.is_empty() {
        writeln!(mod_out, "    let _ = (db, token);")?;
        writeln!(mod_out, "    None")?;
    } else {
        for guard in &guard_structs {
            writeln!(
                mod_out,
                "    if let Ok(auth) = core_web::auth::authenticate_token::<{guard}>(db, token).await {{"
            )?;
            writeln!(
                mod_out,
                "        if let Some(identity) = auth.as_identity() {{"
            )?;
            writeln!(mod_out, "            return Some(identity);")?;
            writeln!(mod_out, "        }}")?;
            writeln!(mod_out, "    }}")?;
        }
        writeln!(mod_out, "    None")?;
    }
    writeln!(mod_out, "}}")?;
    writeln!(mod_out)?;
    writeln!(
        mod_out,
        "pub async fn datatable_actor_from_token(db: &sqlx::PgPool, token: &str) -> Option<DataTableActor> {{"
    )?;
    writeln!(
        mod_out,
        "    let identity = authenticate_any_guard(db, token).await?;"
    )?;
    writeln!(mod_out, "    Some(DataTableActor {{")?;
    writeln!(mod_out, "        id: Some(identity.subject_id),")?;
    writeln!(mod_out, "        guard: Some(identity.guard),")?;
    writeln!(mod_out, "        roles: vec![],")?;
    writeln!(mod_out, "        permissions: identity.abilities,")?;
    writeln!(mod_out, "        attributes: BTreeMap::new(),")?;
    writeln!(mod_out, "    }})")?;
    writeln!(mod_out, "}}")?;

    fs::write(out_dir.join("mod.rs"), mod_out)?;
    Ok(())
}
